# advent of code 2023

## 2023

The current plan for using a different language each day.

### ratings

- tooling: How easy was it to install, how easy to get to hello world, how was there ide support, did the errors messages make sense
- experience: How much experience did I have with this sort of language going in.
- sugar: How much syntactical sugar was built into the language? How easy was it to pull outside modules? How large is the ecosystem?
- brevity: How terse is the language? Is it good for doing things quickly? Is it a good fit for scripting?

1. erlang/OTP (26)
   - tooling (6/10)
   - experience (3/10)
   - sugar (5/10)
   - brevity (4/10)
   - list comprehensions area pretty readable in erlang.
2. perl (v5.30.3)
   - tooling (7/10)
   - experience (2/10)
   - sugar (7/10)
   - brevity (9/10)
   - Like bash but none of the variable prefix rules make sense.
   - Runtime feels "fast." Might just have been this problem.
3. scheme (racket-8.11.1)
   - tooling (4/10)
     - Error messages didn't have worthwhile stack traces. They were truncated and just method names with line numbers.
   - experience (4/10)
   - sugar (3/10)
   - brevity (3/10)
   - build your own mapping functions seems to be "the lisp way."
4. bash
5. F#
6. COBOL 2023
7. nim
8. groovy
9. rust
10. java 1.2 ( first java with collection classes )
11. ruby
12. typescript
13. zig
14. visual basic ( .NET core )
15. c++
16. c
17. lua
18. python
19. java 21
20. C#
21. kotlin
22. deno ( yes, I know this is cheating )
23. dart
24. javascript
25. go

## alternatives

If I can't get a language off the ground, or it seems like the language doesn't fit the problem, here are some backups.

- matlab
- powershell
- oolong
- clojure
- fortran 2018
- actionscript
- ~~python~~
- scala

## outlawed

These have proved trying in the past.

- elixir
- swift/objective-c
- julia
- scheme (too much build-your-own-helper mindset)
